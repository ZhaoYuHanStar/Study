Singleton 的四种方式，简单代码举例，总结性文字见笔记：单例模式。

共列举了4种：

- 预加载

线程安全；

内存浪费；

- 懒加载

线程不安全；

内存相对不浪费；

- 优化的懒加载

线程安全；内存不浪费；高效；

- 静态内部类

真正的按需创建实例，提高空间使用效率

<span style="background:yellow">单例模式应用场景</span>：

- **1.需要生成唯一序列的环境**
- **2.需要频繁实例化然后销毁的对象。**
- **3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。** 
- **4.方便资源相互通信的环境**

<span style="background:yellow">例如</span>：

- **Windows桌面的回收站**
- **网站的计数器**
- **操作系统的文件系统**
- **多线程的线程池的设计**

<span style="background:yellow">单例模式优点</span>：

1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 

2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 

3.提供了对唯一实例的受控访问。 

4.由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 

5.允许可变数目的实例。 

6.避免对共享资源的多重占用。 

<span style="background:yellow">单例模式缺点</span>：

1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 

2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 

3.单例类的职责过重，在一定程度上违背了“单一职责原则”。 

4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

