synchronized 的四种用法，简单代码举例，总结性文字见笔记：并发。



u8c现在的并发处理方式：在修改的时候获取一次时间戳，然后在保存的时候给对应数据的主键加锁，然后再次获取时间戳，对比一下两次时间戳是否一致，一致的话执行保存操作并更新时间戳，否则认为发现了并发。

JUC -> java.util.concurrent包，简称java并发包

锁机制有两个层面

代码层次

通过同步关键字synchronized

1. <span style="background:yellow">修饰一个代码块</span>，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；

当两个并发线程同时访问同一个对象（syncThread）时，在同一个时刻只能有一个线程执行，另一个被阻塞，必须等当前线程执行完这个代码块以后才能执行。thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。

当两个并发线程同时访问同一个类的不同对象时，并发不受控制，synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行，从而发生并发。

一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。

当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。也就是说谁拿到那个锁谁就可以运行它所控制的那段代码。

零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。

2. <span style="background:yellow">修饰一个方法</span>，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；

synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。

synchronized关键字不能继承。想要子类覆盖的方法也同步，有两种方式：1是也加关键字，2是子类方法中调用父类的同步方法

在定义接口方法时不能使用synchronized关键字**。**

构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。

syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。

3. <span style="background:yellow">修饰一个静态的方法</span>，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；

4. <span style="background:yellow">修饰一个类</span>，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

同一时刻里这个类的对象只能由一个线程调用，所有的对象用的同一把锁。

<span style="background:yellow">总结</span>：

A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。

B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。

C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

D.当代码段执行结束或出现异常后会自动释放对监视器的锁定。

E.是非公平锁，在等待获取锁的过程中不可被中断。

F.互斥性，被synchronized修饰的方法同时只能由一个线程执行。

数据库层次

比较典型的就是悲观锁和乐观锁